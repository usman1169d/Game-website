<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slope Ball - Web Games Hub</title>
    <link rel="stylesheet" href="../styles/main.css">
    <style>
        .slope-container {
            position: relative;
            width: 100%;
            height: 600px;
            margin: 0 auto;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            border-radius: 15px;
            overflow: hidden;
            perspective: 1000px;
            perspective-origin: 50% 20%;
        }
        
        .slope-game {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transform: rotateX(75deg) rotateY(0deg);
        }
        
        .slope-track {
            position: absolute;
            width: 100%;
            height: 200%;
            background: 
                linear-gradient(0deg, 
                    rgba(0,255,255,0.1) 0%, 
                    rgba(0,255,255,0.05) 50%, 
                    rgba(0,255,255,0.1) 100%),
                linear-gradient(90deg, 
                    transparent 0%, 
                    rgba(0,255,255,0.3) 1%, 
                    transparent 2%,
                    transparent 98%,
                    rgba(0,255,255,0.3) 99%,
                    transparent 100%),
                repeating-linear-gradient(0deg,
                    transparent 0px,
                    transparent 98px,
                    rgba(0,255,255,0.4) 100px,
                    transparent 102px);
            border-left: 2px solid #00ffff;
            border-right: 2px solid #00ffff;
            left: 20%;
            width: 60%;
            top: -100%;
            z-index: 1;
            animation: trackMove 8s linear infinite;
        }
        
        @keyframes trackMove {
            0% { transform: translateZ(0px) translateY(0px); }
            100% { transform: translateZ(1500px) translateY(100px); }
        }
        
        .ball {
            position: absolute;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 50%, #009944 100%);
            border-radius: 50%;
            box-shadow: 
                0 0 20px rgba(0, 255, 136, 0.8),
                inset -8px -8px 15px rgba(0,0,0,0.4),
                inset 6px 6px 12px rgba(255,255,255,0.3);
            z-index: 100;
            transform-style: preserve-3d;
            animation: ballRoll 0.5s linear infinite;
        }
        
        @keyframes ballRoll {
            0% { transform: rotateY(0deg) rotateX(0deg); }
            100% { transform: rotateY(360deg) rotateX(360deg); }
        }
        
        .obstacle {
            position: absolute;
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #ff1744, #d50000);
            border-radius: 8px;
            box-shadow: 
                0 0 25px rgba(255, 23, 68, 0.8),
                inset -5px -5px 10px rgba(0,0,0,0.5),
                inset 3px 3px 8px rgba(255,150,150,0.4);
            z-index: 50;
            transform-style: preserve-3d;
        }
        
        .wall {
            position: absolute;
            width: 20px;
            height: 100px;
            background: linear-gradient(180deg, #ff4444, #cc0000);
            box-shadow: 
                0 0 15px rgba(255, 0, 0, 0.5),
                inset -2px 0 4px rgba(0,0,0,0.3);
            z-index: 50;
            transform-style: preserve-3d;
        }
        
        .speed-boost {
            position: absolute;
            width: 28px;
            height: 28px;
            background: radial-gradient(circle, #ffff00, #ffaa00);
            border-radius: 50%;
            box-shadow: 
                0 0 25px rgba(255, 255, 0, 1),
                inset -3px -3px 6px rgba(0,0,0,0.2),
                inset 2px 2px 4px rgba(255,255,255,0.4);
            animation: powerupSpin 1s linear infinite;
            z-index: 50;
            transform-style: preserve-3d;
        }
        
        @keyframes powerupSpin {
            0% { 
                transform: rotateY(0deg) rotateZ(0deg) scale(1);
                box-shadow: 0 0 25px rgba(255, 255, 0, 1), inset -3px -3px 6px rgba(0,0,0,0.2), inset 2px 2px 4px rgba(255,255,255,0.4);
            }
            50% { 
                transform: rotateY(180deg) rotateZ(180deg) scale(1.2);
                box-shadow: 0 0 35px rgba(255, 255, 0, 1.5), inset -3px -3px 6px rgba(0,0,0,0.2), inset 2px 2px 4px rgba(255,255,255,0.4);
            }
            100% { 
                transform: rotateY(360deg) rotateZ(360deg) scale(1);
                box-shadow: 0 0 25px rgba(255, 255, 0, 1), inset -3px -3px 6px rgba(0,0,0,0.2), inset 2px 2px 4px rgba(255,255,255,0.4);
            }
        }
        
        .tunnel-wall {
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at center, 
                    transparent 25%, 
                    rgba(0,100,200,0.1) 40%, 
                    rgba(0,50,150,0.3) 60%, 
                    rgba(0,20,100,0.6) 80%, 
                    rgba(0,10,50,0.8) 100%);
            border-radius: 50%;
            transform: rotateX(90deg) translateZ(-300px);
            z-index: 0;
        }
        
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            border-radius: 50%;
            box-shadow: 0 0 6px #00ffff;
            animation: particleMove 3s linear infinite;
            z-index: 10;
        }
        
        @keyframes particleMove {
            0% { 
                transform: translateZ(-500px) translateY(0px);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { 
                transform: translateZ(200px) translateY(-100px);
                opacity: 0;
            }
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 200;
            backdrop-filter: blur(5px);
        }
        
        .game-overlay.hidden {
            display: none;
        }
        
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 150;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 0.9rem;
            z-index: 150;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .speed-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(0deg,
                    transparent 0px,
                    rgba(255,255,255,0.1) 1px,
                    transparent 2px,
                    transparent 50px);
            animation: speedLinesMove 0.5s linear infinite;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .speed-lines.active {
            opacity: 1;
        }
        
        @keyframes speedLinesMove {
            0% { transform: translateY(0px); }
            100% { transform: translateY(50px); }
        }
    </style>
</head>
<body class="game-page" style="display: block;">
    <div class="game-header">
        <a href="../index.html" class="back-btn">‚Üê Back to Games</a>
        <h1>‚öΩ Slope Ball</h1>
    </div>

    <div class="game-container">
        <div class="slope-container">
            <div class="slope-game" id="gameArea">
                <div class="tunnel-wall"></div>
                <div class="slope-track"></div>
                <div class="speed-lines" id="speedLines"></div>
                <div class="ball" id="ball"></div>
                
                <div class="game-overlay" id="gameOverlay">
                    <h2>üéÆ Slope Ball</h2>
                    <p>Roll down the endless slope at increasing speed!</p>
                    <p>Use A/D or ‚Üê/‚Üí to steer ‚Ä¢ Avoid red obstacles ‚Ä¢ Collect yellow boosts</p>
                    <p><strong>Don't fall off the track!</strong></p>
                    <button onclick="startGame()" style="margin-top: 1rem; padding: 10px 20px; font-size: 1rem; background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; border-radius: 5px; cursor: pointer;">Start Game</button>
                </div>
                
                <div class="hud">
                    <div>Score: <span id="score">0</span></div>
                    <div>Speed: <span id="speed">1.0</span>x</div>
                    <div>Distance: <span id="distance">0</span>m</div>
                </div>
                
                <div class="controls-info">
                    <strong>Slope Controls:</strong><br>
                    A/D or ‚Üê/‚Üí to steer the ball<br>
                    Stay on track and avoid obstacles!
                </div>
            </div>
        </div>
        
        <div class="game-controls">
            <button onclick="startGame()">Start Game</button>
            <button onclick="pauseGame()">Pause</button>
            <button onclick="resetGame()">Reset</button>
        </div>
    </div>

    <script src="../js/main.js"></script>
    <script>
        class SlopeGame {
            constructor() {
                console.log('Initializing 3D SlopeGame...');
                
                this.gameArea = document.getElementById('gameArea');
                this.ball = document.getElementById('ball');
                this.overlay = document.getElementById('gameOverlay');
                this.speedLines = document.getElementById('speedLines');
                this.scoreElement = document.getElementById('score');
                this.speedElement = document.getElementById('speed');
                this.distanceElement = document.getElementById('distance');
                
                // Initialize arrays first
                this.obstacles = [];
                this.powerups = [];
                this.particles = [];
                
                // Debug element finding
                console.log('3D Game elements found:', {
                    gameArea: !!this.gameArea,
                    ball: !!this.ball,
                    overlay: !!this.overlay,
                    speedLines: !!this.speedLines,
                    scoreElement: !!this.scoreElement,
                    speedElement: !!this.speedElement,
                    distanceElement: !!this.distanceElement
                });
                
                this.reset();
                this.setupControls();
                this.createParticles();
                
                console.log('3D SlopeGame initialization complete');
            }
            
            reset() {
                // Get container dimensions
                const containerRect = this.gameArea.getBoundingClientRect();
                this.containerWidth = containerRect.width || 500;
                this.containerHeight = containerRect.height || 600;
                
                // Slope game positioning - ball starts in center
                this.ballX = this.containerWidth / 2 - 15; // Center minus half ball width
                this.ballY = this.containerHeight / 2; // Middle of screen
                this.ballZ = 0; // 3D depth
                this.ballVelX = 0; // Horizontal velocity
                this.ballVelY = 0; // Vertical velocity (falling)
                this.ballVelZ = 5; // Forward velocity (always moving forward)
                this.ballSpeed = 0.3; // Horizontal control sensitivity
                this.gravity = 0.4; // Constant downward pull
                this.gameSpeed = 5; // Base forward speed
                this.acceleration = 0.01; // Speed increases over time
                this.score = 0;
                this.distance = 0;
                this.gameRunning = false;
                this.keys = {};
                this.bounce = 0.7; // Bounce factor for collisions
                
                // Track boundaries (like original Slope)
                this.trackLeft = this.containerWidth * 0.2;
                this.trackRight = this.containerWidth * 0.8;
                
                // Clear obstacles and powerups (with safety checks)
                if (this.obstacles && Array.isArray(this.obstacles)) {
                    this.obstacles.forEach(obstacle => obstacle.element && obstacle.element.remove());
                    this.obstacles = [];
                }
                if (this.powerups && Array.isArray(this.powerups)) {
                    this.powerups.forEach(powerup => powerup.element && powerup.element.remove());
                    this.powerups = [];
                }
                
                // Initialize arrays if they don't exist
                if (!this.obstacles) this.obstacles = [];
                if (!this.powerups) this.powerups = [];
                
                this.updateBallPosition();
                this.updateHUD();
                this.updateSpeedLines();
            }
            
            createParticles() {
                // Create ambient particles for 3D effect
                for (let i = 0; i < 20; i++) {
                    this.createParticle();
                }
            }
            
            createParticle() {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * this.containerWidth + 'px';
                particle.style.top = Math.random() * this.containerHeight + 'px';
                particle.style.animationDelay = Math.random() * 3 + 's';
                this.gameArea.appendChild(particle);
                
                // Remove and recreate particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove();
                        if (this.gameRunning) this.createParticle();
                    }
                }, 3000);
            }
            
            updateSpeedLines() {
                if (this.speedLines) {
                    if (this.gameSpeed > 4) {
                        this.speedLines.classList.add('active');
                        this.speedLines.style.animationDuration = (1 / (this.gameSpeed / 3)) + 's';
                    } else {
                        this.speedLines.classList.remove('active');
                    }
                }
            }
            
            setupControls() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    e.preventDefault(); // Prevent page scroll
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Touch controls for mobile
                let touchStartX = 0;
                let touchCurrentX = 0;
                
                this.gameArea.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    e.preventDefault();
                });
                
                this.gameArea.addEventListener('touchmove', (e) => {
                    touchCurrentX = e.touches[0].clientX;
                    const diff = touchCurrentX - touchStartX;
                    
                    if (Math.abs(diff) > 10) {
                        if (diff > 0) {
                            this.keys['d'] = true;
                            this.keys['a'] = false;
                        } else {
                            this.keys['a'] = true;
                            this.keys['d'] = false;
                        }
                    } else {
                        this.keys['a'] = false;
                        this.keys['d'] = false;
                    }
                    e.preventDefault();
                });
                
                this.gameArea.addEventListener('touchend', (e) => {
                    this.keys['a'] = false;
                    this.keys['d'] = false;
                    e.preventDefault();
                });
            }
            
            jump() {
                if (this.onGround) {
                    this.ballVelY = this.jumpPower;
                    this.onGround = false;
                    GameUtils.playSound(660, 150);
                }
            }
            
            spawnObstacle() {
                if (Math.random() < 0.02 + this.gameSpeed * 0.002) {
                    const obstacle = document.createElement('div');
                    obstacle.className = 'obstacle';
                    
                    // Spawn obstacles randomly within track boundaries
                    const minX = this.trackLeft;
                    const maxX = this.trackRight - 40;
                    
                    obstacle.style.left = (minX + Math.random() * (maxX - minX)) + 'px';
                    obstacle.style.top = '-100px'; // Start above screen
                    obstacle.style.transform = 'translateZ(-500px) rotateY(0deg)';
                    this.gameArea.appendChild(obstacle);
                    
                    this.obstacles.push({
                        element: obstacle,
                        x: parseInt(obstacle.style.left),
                        y: -100,
                        z: -500,
                        width: 40,
                        height: 40,
                        rotation: 0
                    });
                }
            }
            
            spawnPowerup() {
                if (Math.random() < 0.005) {
                    const powerup = document.createElement('div');
                    powerup.className = 'speed-boost';
                    
                    // Spawn powerups within track boundaries
                    const minX = this.trackLeft;
                    const maxX = this.trackRight - 28;
                    
                    powerup.style.left = (minX + Math.random() * (maxX - minX)) + 'px';
                    powerup.style.top = '-100px';
                    powerup.style.transform = 'translateZ(-500px)';
                    this.gameArea.appendChild(powerup);
                    
                    this.powerups.push({
                        element: powerup,
                        x: parseInt(powerup.style.left),
                        y: -100,
                        z: -500,
                        width: 28,
                        height: 28
                    });
                }
            }
            
            updateBallPosition() {
                if (this.ball) {
                    // Slope-style 3D positioning
                    const perspective = 800 + this.ballZ;
                    const scale = Math.max(0.4, perspective / 800);
                    
                    this.ball.style.left = this.ballX + 'px';
                    this.ball.style.top = this.ballY + 'px';
                    this.ball.style.transform = `
                        translateZ(${this.ballZ}px) 
                        scale(${scale})
                        rotateY(${this.ballVelX * 10}deg)
                        rotateX(${this.ballVelY * 5}deg)
                    `;
                    
                    // Update ball roll animation speed based on velocity
                    const rollSpeed = Math.max(0.1, 1 / (Math.abs(this.ballVelX) + Math.abs(this.ballVelY) + 1));
                    this.ball.style.animationDuration = rollSpeed + 's';
                } else {
                    console.error('Ball element not found');
                }
            }
            
            checkCollision(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + 20 > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + 20 > obj2.y;
            }
            
            update() {
                if (!this.gameRunning) return;
                
                // Slope-style movement: ball is always moving forward and falling
                
                // Horizontal movement (A/D keys)
                if (this.keys['a'] || this.keys['arrowleft']) {
                    this.ballVelX -= this.ballSpeed;
                }
                if (this.keys['d'] || this.keys['arrowright']) {
                    this.ballVelX += this.ballSpeed;
                }
                
                // Apply air resistance to horizontal movement
                this.ballVelX *= 0.98;
                
                // Constant gravity (ball always falls)
                this.ballVelY += this.gravity;
                
                // Constant forward movement (like Slope)
                this.ballVelZ = this.gameSpeed;
                
                // Update ball position
                this.ballX += this.ballVelX;
                this.ballY += this.ballVelY;
                this.ballZ += this.ballVelZ;
                
                // Track boundary collision (walls)
                if (this.ballX <= this.trackLeft) {
                    this.ballX = this.trackLeft;
                    this.ballVelX = Math.abs(this.ballVelX) * this.bounce; // Bounce off left wall
                    GameUtils.playSound(440, 100);
                }
                if (this.ballX >= this.trackRight - 30) {
                    this.ballX = this.trackRight - 30;
                    this.ballVelX = -Math.abs(this.ballVelX) * this.bounce; // Bounce off right wall
                    GameUtils.playSound(440, 100);
                }
                
                // Game over if ball falls too far
                if (this.ballY > this.containerHeight + 100) {
                    this.gameOver();
                    return;
                }
                
                // Spawn obstacles and powerups
                this.spawnObstacle();
                this.spawnPowerup();
                
                // Update obstacles with Slope-style movement
                this.obstacles.forEach((obstacle, index) => {
                    obstacle.y += this.gameSpeed;
                    obstacle.z += this.gameSpeed;
                    
                    // 3D perspective scaling
                    const scale = Math.max(0.2, 1 - obstacle.z / 800);
                    obstacle.element.style.top = obstacle.y + 'px';
                    obstacle.element.style.transform = 
                        `translateZ(${obstacle.z}px) scale(${scale})`;
                    
                    // Check collision with ball
                    if (this.checkCollision({x: this.ballX, y: this.ballY}, obstacle)) {
                        // Slope-style collision: bounce and lose speed
                        this.ballVelX *= -0.8;
                        this.ballVelY = -8; // Bounce up
                        this.gameSpeed *= 0.7; // Slow down significantly
                        GameUtils.playSound(220, 300);
                        
                        // Remove the obstacle
                        obstacle.element.remove();
                        this.obstacles.splice(index, 1);
                        
                        // Don't end game immediately, just penalize
                        return;
                    }
                    
                    // Remove obstacles that have passed
                    if (obstacle.y > this.containerHeight + 100 || obstacle.z > 200) {
                        obstacle.element.remove();
                        this.obstacles.splice(index, 1);
                        this.score += 5; // Small score for survival
                    }
                });
                
                // Update powerups
                this.powerups.forEach((powerup, index) => {
                    powerup.y += this.gameSpeed;
                    powerup.z += this.gameSpeed;
                    
                    // 3D perspective scaling with pulse
                    const scale = Math.max(0.2, 1 - powerup.z / 800);
                    const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.1;
                    powerup.element.style.top = powerup.y + 'px';
                    powerup.element.style.transform = 
                        `translateZ(${powerup.z}px) scale(${scale * pulse})`;
                    
                    // Check collision with ball
                    if (this.checkCollision({x: this.ballX, y: this.ballY}, powerup)) {
                        powerup.element.remove();
                        this.powerups.splice(index, 1);
                        this.gameSpeed = Math.min(this.gameSpeed * 1.2, 15); // Speed boost with cap
                        this.score += 50;
                        GameUtils.playSound(880, 200);
                        return;
                    }
                    
                    // Remove powerups that have passed
                    if (powerup.y > this.containerHeight + 100 || powerup.z > 200) {
                        powerup.element.remove();
                        this.powerups.splice(index, 1);
                    }
                });
                
                // Update speed lines and particles
                this.updateSpeedLines();
                
                // Gradual acceleration (like Slope)
                this.gameSpeed += this.acceleration;
                this.gameSpeed = Math.min(this.gameSpeed, 12); // Speed cap
                this.distance += this.gameSpeed * 0.1;
                this.score += Math.floor(this.gameSpeed * 0.1); // Distance-based scoring
                
                this.updateBallPosition();
                this.updateHUD();
            }
            
            updateHUD() {
                this.scoreElement.textContent = Math.floor(this.score);
                this.speedElement.textContent = (this.gameSpeed / 5).toFixed(1);
                this.distanceElement.textContent = Math.floor(this.distance);
            }
            
            gameLoop() {
                this.update();
                if (this.gameRunning) {
                    requestAnimationFrame(() => this.gameLoop());
                }
            }
            
            start() {
                if (this.gameRunning) return;
                
                console.log('Starting game...');
                this.gameRunning = true;
                
                // Hide overlay
                if (this.overlay) {
                    this.overlay.classList.add('hidden');
                    console.log('Overlay hidden');
                } else {
                    console.error('Overlay element not found');
                }
                
                // Start game loop
                this.gameLoop();
                console.log('Game loop started');
            }
            
            pause() {
                this.gameRunning = false;
            }
            
            gameOver() {
                this.gameRunning = false;
                GameUtils.playSound(220, 500);
                
                setTimeout(() => {
                    alert(`Game Over!\n\nFinal Score: ${Math.floor(this.score)}\nDistance: ${Math.floor(this.distance)}m\nMax Speed: ${(this.gameSpeed / 2).toFixed(1)}x`);
                    this.showOverlay();
                }, 100);
            }
            
            showOverlay() {
                this.overlay.classList.remove('hidden');
                this.overlay.innerHTML = `
                    <h2>Game Over!</h2>
                    <p>Score: ${Math.floor(this.score)}</p>
                    <p>Distance: ${Math.floor(this.distance)}m</p>
                    <p>Max Speed: ${(this.gameSpeed / 2).toFixed(1)}x</p>
                    <button onclick="resetGame()" style="margin-top: 1rem; padding: 10px 20px; font-size: 1rem;">Play Again</button>
                `;
            }
        }
        
        // Initialize game when page loads
        let game;
        
        window.addEventListener('load', function() {
            try {
                game = new SlopeGame();
                console.log('Slope Game initialized successfully');
            } catch (error) {
                console.error('Error initializing Slope Game:', error);
                alert('Error starting game: ' + error.message);
            }
        });
        
        // Game control functions
        function startGame() {
            try {
                if (game) {
                    game.start();
                    console.log('Game started');
                } else {
                    console.error('Game not initialized');
                }
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game: ' + error.message);
            }
        }
        
        function pauseGame() {
            try {
                if (game) {
                    game.pause();
                }
            } catch (error) {
                console.error('Error pausing game:', error);
            }
        }
        
        function resetGame() {
            try {
                if (game) {
                    game.pause();
                    game.reset();
                    game.overlay.classList.remove('hidden');
                    game.overlay.innerHTML = `
                        <h2>Slope Ball</h2>
                        <p>Navigate the ball down the endless slope!</p>
                        <p>Avoid red obstacles and collect yellow speed boosts</p>
                        <button onclick="startGame()" style="margin-top: 1rem; padding: 10px 20px; font-size: 1rem;">Start Game</button>
                    `;
                } else {
                    console.error('Game not initialized');
                }
            } catch (error) {
                console.error('Error resetting game:', error);
            }
        }
    </script>
</body>
</html>